package org.eqasim.switzerland.drt.mode_choice.cost.drt_cost_calculator;

import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;
import org.eqasim.switzerland.drt.mode_choice.parameters.SwissDrtCostParameters;
import org.matsim.api.core.v01.Id;
import org.matsim.contrib.drt.analysis.DrtEventSequenceCollector;
import org.matsim.contrib.drt.analysis.DrtLegsAnalyser;
import org.matsim.contrib.drt.analysis.DrtVehicleDistanceStats;
import org.matsim.core.controler.events.IterationEndsEvent;
import org.matsim.core.controler.listener.IterationEndsListener;
import org.matsim.vehicles.Vehicle;

import javax.inject.Inject;
import java.util.Map;

public class DrtCostControlerListener implements IterationEndsListener {

    DrtVehicleDistanceStats vehicleDistanceStats;
    @Inject
    SwissDrtCostParameters swissDrtCostParameters;
    DrtEventSequenceCollector drtEventSequenceCollector;

    public DrtCostControlerListener(DrtVehicleDistanceStats vehicleDistanceStats, DrtEventSequenceCollector drtEventSequenceCollector){
        this.vehicleDistanceStats  = vehicleDistanceStats;
        this.drtEventSequenceCollector = drtEventSequenceCollector;
    }
    @Override
    public void notifyIterationEnds(IterationEndsEvent event) {
        setNewCost();

    }

    private void setNewCost() {

        //get total distances of vehicles
        //- get it from the output file generated by drt analysis - but it has to be at iteration start
        //- use event handlers to track vehicles and their distances
        //make generic for multiple drt operators
        //distances per operators - prices per operators

        //get total number of vehicles

        //get number of trips

        Double totalDistance_m = DrtLegsAnalyser.getTotalDistance(vehicleDistanceStats.getVehicleStates());

        double testDist = getTotalPassengerDistanceTraveled(vehicleDistanceStats);
        double BTestDist = vehicleDistanceStats.getTravelDistances().values().stream().reduce(0.0,Double::sum);
        Double totalPassengerDistance_m = testDist;
        int fleetsize = vehicleDistanceStats.getVehicleStates().size();
        long num_trips = getDrtLegCount(drtEventSequenceCollector);

        //Boesch cost calculator - check sebastian's paper
        Double costFleet = swissDrtCostParameters.COST_PER_DISTANCE_PER_VEHICLE_KM_DRT * totalDistance_m / 1000
                + swissDrtCostParameters.COST_PER_TRIP_DRT * num_trips
                + swissDrtCostParameters.COST_PER_VEHICLE_PER_DAY_DRT * fleetsize;

        Double pAMoD = Math.max(0,
                (costFleet - swissDrtCostParameters.drtBaseFare_CHF * num_trips) / (totalPassengerDistance_m / 1000));

        if (Double.isFinite(pAMoD)) {
            //swissDrtCostParameters.setDrtPricePerKm(pAMoD);
        }

//        log.info("The drt total distance is " + totalDistance_m);
//        log.info("The drt total passenger distance is " + totalPassengerDistance_m);
//        log.info("The drt cost for the fleet is " + costFleet);
//        log.info("The drt cost for the next iteration is " + pAMoD);
    }

    public static double getTotalPassengerDistanceTraveled(DrtVehicleDistanceStats stats) {
        Map<Id<Vehicle>, DrtVehicleDistanceStats.VehicleState> vehicleDistances = stats.getVehicleStates();

        DescriptiveStatistics driven = new DescriptiveStatistics();
        for (DrtVehicleDistanceStats.VehicleState state : vehicleDistances.values()) {
            driven.addValue(state.totalPassengerTraveledDistance);
        }
        return driven.getSum();
    }

    public static long getDrtLegCount(DrtEventSequenceCollector drtEventSequenceCollector) {
        return drtEventSequenceCollector.getPerformedRequestSequences()
                .values()
                .stream()
                .filter(DrtEventSequenceCollector.EventSequence::isCompleted).count();

    }

}
