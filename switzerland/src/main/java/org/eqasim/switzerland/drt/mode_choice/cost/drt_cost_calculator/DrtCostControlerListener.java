package org.eqasim.switzerland.drt.mode_choice.cost.drt_cost_calculator;

import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;
import org.eqasim.switzerland.drt.mode_choice.parameters.SwissDrtCostParameters;
import org.matsim.api.core.v01.Id;
import org.matsim.contrib.drt.analysis.DrtEventSequenceCollector;
import org.matsim.contrib.drt.analysis.DrtLegsAnalyser;
import org.matsim.contrib.drt.analysis.DrtVehicleDistanceStats;
import org.matsim.core.controler.events.IterationEndsEvent;
import org.matsim.core.controler.listener.IterationEndsListener;
import org.matsim.vehicles.Vehicle;

import javax.inject.Inject;
import java.util.Map;

public class DrtCostControlerListener implements IterationEndsListener {

    DrtVehicleDistanceStats vehicleDistanceStats;
    SwissDrtCostParameters swissDrtCostParameters;
    DrtEventSequenceCollector drtEventSequenceCollector;

    public DrtCostControlerListener(DrtVehicleDistanceStats vehicleDistanceStats, DrtEventSequenceCollector drtEventSequenceCollector, SwissDrtCostParameters swissDrtCostParameters){
        this.vehicleDistanceStats  = vehicleDistanceStats;
        this.drtEventSequenceCollector = drtEventSequenceCollector;
        this.swissDrtCostParameters = swissDrtCostParameters;
    }
    @Override
    public void notifyIterationEnds(IterationEndsEvent event) {
        if (event.getIteration() >=25){ //ToDo make this configurable
        setNewCost();
        }
        writeCosts();

    }

    private void setNewCost() {

        //get total distances of vehicles
        //- get it from the output file generated by drt analysis - but it has to be at iteration start
        //- use event handlers to track vehicles and their distances
        //make generic for multiple drt operators
        //distances per operators - prices per operators

        //get total number of vehicles

        //get number of trips

        Double totalDistance_m = DrtLegsAnalyser.getTotalDistance(vehicleDistanceStats.getVehicleStates());
        Double totalPassengerDistance_m = vehicleDistanceStats.getTravelDistances().values().stream().reduce(0.0,Double::sum);
        int fleetsize = vehicleDistanceStats.getVehicleStates().size();
        long num_trips = getDrtLegCount(drtEventSequenceCollector);

        //Boesch cost calculator - check sebastian's paper
        Double costFleet = swissDrtCostParameters.COST_PER_DISTANCE_PER_VEHICLE_KM_DRT * totalDistance_m / 1000
                + swissDrtCostParameters.COST_PER_TRIP_DRT * num_trips
                + swissDrtCostParameters.COST_PER_VEHICLE_PER_DAY_DRT * fleetsize;

        Double pAMoD = Math.max(0,
                (costFleet - swissDrtCostParameters.drtBaseFare_CHF * num_trips) / (totalPassengerDistance_m / 1000));

        if (Double.isFinite(pAMoD)) {
            swissDrtCostParameters.setDrtPricePerKm(pAMoD);
        }

    }

//    public static double getTotalPassengerDistanceTraveled(DrtVehicleDistanceStats stats) {
//        Map<Id<Vehicle>, DrtVehicleDistanceStats.VehicleState> vehicleDistances = stats.getVehicleStates();
//
//        DescriptiveStatistics driven = new DescriptiveStatistics();
//        for (DrtVehicleDistanceStats.VehicleState state : vehicleDistances.values()) {
//            driven.addValue(state.totalPassengerTraveledDistance);
//        }
//        return driven.getSum();
//    }

    public static long getDrtLegCount(DrtEventSequenceCollector drtEventSequenceCollector) {
        return drtEventSequenceCollector.getPerformedRequestSequences()
                .values()
                .stream()
                .filter(DrtEventSequenceCollector.EventSequence::isCompleted).count();

    }

    private void writeCosts(){
        //ToDo output cost as it changes in a csv file
    }

}
